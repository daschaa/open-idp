// Package idp contains the implementation of the Identity Provider (IdP) server.
// It provides handlers for token introspection and token generation and other related functionalities.
package idp

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/daschaa/open-idp/internal/repository"
	"github.com/dgrijalva/jwt-go"
	"github.com/thanhpk/randstr"
	"net/http"
	"time"
)

type introspectRequest struct {
	Token *string `json:"token"`
}

type tokenRequest struct {
	ClientId     string `json:"client_id"`
	ClientSecret string `json:"client_secret"`
	GrantType    string `json:"grant_type"`
}

type ServerOption func(c *Server)

// Server represents the IdP server with its dependencies.
type Server struct {
	clientRepository *repository.ClientRepository
	clock            repository.Clock
	signingKey       *[]byte
}

type systemClock struct{}

func (c systemClock) Now() time.Time {
	return time.Now()
}

func (s *Server) validateClient(clientId string, clientSecret string) (bool, error) {
	client, err := (*s.clientRepository).GetClient(clientId)
	if err != nil {
		return false, err
	}

	if !(client.ClientSecret == clientSecret) {
		return false, errors.New("Secret does not match")
	}

	return true, nil
}

// IntrospectHandler handles the introspection of a token.
// It decodes the incoming request, validates the token, and returns the token's active status and subject.
//
// If the request body is invalid or the token is nil, it responds with a 400 Bad Request status.
// If the token is invalid, it responds with a JSON object indicating the token is inactive.
// If the token is valid, it verifies the token's expiration and responds with the token's active status and subject.
func (s *Server) IntrospectHandler(w http.ResponseWriter, r *http.Request) {
	request := introspectRequest{}
	err := json.NewDecoder(r.Body).Decode(&request)

	if err != nil || request.Token == nil {
		http.Error(w, "Invalid body", http.StatusBadRequest)
		return
	}
	claims := jwt.MapClaims{}
	token, err := jwt.ParseWithClaims(*request.Token, claims, func(token *jwt.Token) (interface{}, error) {
		return *s.signingKey, nil
	})
	w.Header().Set("Content-Type", "application/json")
	if !token.Valid {
		json.NewEncoder(w).Encode(map[string]interface{}{"active": false})
		return
	}

	subject := claims["sub"]
	client, err := (*s.clientRepository).GetClient(fmt.Sprintf("%s", subject))
	if err != nil {
		json.NewEncoder(w).Encode(map[string]interface{}{"active": false})
		return
	}

	active := claims.VerifyExpiresAt(s.clock.Now().Unix(), true)

	if !active {
		json.NewEncoder(w).Encode(map[string]interface{}{"active": active})
		return
	}

	err = json.NewEncoder(w).Encode(map[string]interface{}{"active": active, "sub": client.ClientId})
}

// TokenHandler handles the generation of a new token.
// It decodes the incoming request, validates the client credentials, and returns a new token.
//
// If the request body is invalid, it responds with a 400 Bad Request status.
// If the grant type is unsupported, it responds with a 400 Bad Request status.
// If the client is not authorized, it responds with a 401 Unauthorized status.
// If the token generation is successful, it responds with the token and its details.
func (s *Server) TokenHandler(w http.ResponseWriter, r *http.Request) {
	request := tokenRequest{}
	err := json.NewDecoder(r.Body).Decode(&request)

	if err != nil {
		http.Error(w, "Invalid body", http.StatusBadRequest)
		return
	}

	if request.GrantType != "client_credentials" {
		http.Error(w, "Unsupported grant type", http.StatusBadRequest)
		return
	}

	ok, err := s.validateClient(request.ClientId, request.ClientSecret)

	if !ok {
		http.Error(w, "Client is not authorized", http.StatusUnauthorized)
		return
	}

	token, _ := jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.MapClaims{
		"sub":   request.ClientId,
		"exp":   s.clock.Now().Add(time.Hour).Unix(),
		"scope": "read:example",
	}).SignedString(*s.signingKey)

	w.Header().Set("Content-Type", "application/json")
	err = json.NewEncoder(w).Encode(map[string]string{"access_token": token, "token_type": "Bearer", "expires_in": "3600"})
	if err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}
}

// WithSigningKey is a ServerOption that sets the signing key for the server.
// The signing key is used to sign the tokens generated by the server.
func WithSigningKey(key *[]byte) ServerOption {
	return func(s *Server) {
		s.signingKey = key
	}
}

// WithClock is a ServerOption that sets the clock for the server.
// The clock is used to get the current time, which is useful for token expiration.
func WithClock(clock repository.Clock) ServerOption {
	return func(s *Server) {
		s.clock = clock
	}
}

// New creates a new IdP server with the provided client repository.
// It generates a random signing key for token generation.
func New(repository repository.ClientRepository, opts ...ServerOption) *Server {
	token := []byte(randstr.String(16))

	server := &Server{
		clientRepository: &repository,
		clock:            systemClock{},
		signingKey:       &token,
	}

	for _, opt := range opts {
		opt(server)
	}
	return server
}
